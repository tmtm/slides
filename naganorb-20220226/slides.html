<section>

<h2>Linuxç”¨ã‚­ãƒ¼ãƒªãƒãƒƒãƒ‘ãƒ¼ã‚’ä½œã‚‹æŠ€è¡“</h2>

<p>Nagano.rb #9</p>

<p>2022-02-26</p>

<p>ã¨ã¿ãŸã¾ã•ã²ã‚</p>

</section>
<section>

<h3>è‡ªå·±ç´¹ä»‹</h3>

<p><img src="images/icon2.jpg" alt="" style="position:absolute;top:0%;right:0;width:180px;border:0px"></p>

<ul>
  <li>ã¨ã¿ãŸã¾ã•ã²ã‚</li>
  <li><a href="https://twitter.com/tmtms">https://twitter.com/tmtms</a></li>
  <li><a href="https://blog.tmtms.net">https://blog.tmtms.net</a></li>
  <li><a href="https://zenn.dev/tmtms">https://zenn.dev/tmtms</a></li>
  <li>MySQL / ãƒ¡ãƒ¼ãƒ« / æ–‡å­—åŒ–ã‘</li>
</ul>

</section>
<section>

<h3>Linuxç”¨ã‚­ãƒ¼ãƒªãƒãƒƒãƒ‘ãƒ¼ã‚’ä½œã£ãŸ</h3>

<p>Linux ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ç’°å¢ƒã‚’ä½¿ã£ã¦ã‚‹äººå‘ã‘</p>

</section>
<section>

<h3>çµŒç·¯</h3>

<p>11æœˆã«è»¢è·ã—ã¦äººç”Ÿåˆ Mac</p>

<p>ã‚­ãƒ¼ãƒãƒƒãƒ—ã«æ…£ã‚Œãªã„</p>

<p>ã§ã‚‚ Mac ã®ã‚­ãƒ¼ãƒãƒƒãƒ—ã®æ–¹ãŒè‰¯ã•ãã†<br>
(Ctrl+N ã‚„ Ctrl+P ãŒãƒ–ãƒ©ã‚¦ã‚¶ã«å–ã‚‰ã‚Œãªã„)</p>

<p>ä»•äº‹ä»¥å¤–ã§ä½¿ã£ã¦ã‚‹ Linux ã§ã‚‚ Mac ã¨åŒã˜ã«ã—ã‚ˆã†ï¼</p>

</section>
<section>

<p>ã€Œæœ€å¼·ã®ã‚­ãƒ¼ãƒªãƒãƒƒãƒ‘ãƒ¼ xremapã€<br>
<a href="https://k0kubun.hatenablog.com/entry/xremap">https://k0kubun.hatenablog.com/entry/xremap</a></p>

<p>ä¾¿åˆ©ï¼</p>

</section>
<section>

<p>Ctrl-N ã‚’ â†“<br>
Ctrl-P ã‚’ â†‘<br>
Ctrl-F ã‚’ â†’<br>
Ctrl-B ã‚’ â†<br>
Alt-[A-Z] ã‚’ Ctrl-[A-Z]</p>

<p>ã¿ãŸã„ãªæ„Ÿã˜ã«ã™ã‚Œã°è‰¯ã•ãã†</p>

</section>
<section>

<p>Ctrl-K ã¯æ™®é€šã¯è¡Œæœ«ã¾ã§å‰Šé™¤</p>

<p>ã§ã‚‚æ—¥æœ¬èªå…¥åŠ›æ™‚ã«ã¯ Ctrl-K ã¯ã‚«ã‚¿ã‚«ãƒŠå¤‰æ›ã«ã—ãŸã„</p>

<p>ã§ããªãã†â€¦ğŸ¤”</p>

<p>ã˜ã‚ƒã‚è‡ªåˆ†ã§ä½œã£ã¦ã¿ã‚‹ã‹</p>

</section>
<section>

<h3>Rkremap</h3>

<p><a href="https://github.com/tmtm/rkremap">https://github.com/tmtm/rkremap</a></p>

</section>
<section>

<p>ã‚¢ãƒ—ãƒªã§ã¯ãªããƒ©ã‚¤ãƒ–ãƒ©ãƒª</p>

<p>è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã§ã¯ãªããƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ãå¿…è¦ã‚ã‚Š</p>

<p style="font-size:80%">YAML ã¯ã¤ã‚‰ã„â€¦<br>
â†“<br>
Ruby ã® DSL ã‚‚ã„ã„ã‹ã‚‚â€¦<br>
â†“<br>
ã ã£ãŸã‚‰ Ruby ãƒ—ãƒ­ã‚°ãƒ©ãƒ æ›¸ã‘ã°ã„ã„ã‚“ã˜ã‚ƒã­</p>

</section>
<section>

<h3>å®Ÿè¡Œæ™‚ã«è¦rootæ¨©é™</h3>

<p>ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ input ã‚°ãƒ«ãƒ¼ãƒ—ã«è¿½åŠ ã™ã‚Œã°ã„ã„ã‚“ã ã‘ã©<br>
ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£çš„ã«ã¡ã‚‡ã£ã¨ã“ã‚ã„ã‹ã‚‚</p>

<p style="font-size:80%">sudo ãªã—ã§ã‚„ã‚‹ã«ã¯<br>
<a href="https://github.com/k0kubun/xremap#usage">https://github.com/k0kubun/xremap#usage</a><br>
ã€ŒOption 2: Run xremap without sudoã€</p>

</section>
<section>

<p>ä¾‹</p>

<pre style="font-size:60%"><code class="language-ruby">require 'rkremap'
include Rkremap::KeyCode
rk = Rkremap.new
rk.grab = true
rk.x11 = true
rk.start do |code, mod, app|
  # Emacs ã‚„ç«¯æœ«ã§ã¯ãã®ã¾ã¾
  if app.class_name == 'Emacs' || app.class_name =~ /terminal/i
    rk.key(code, mod)
    next
  end
  # ALT+[A-Z] ã¯ Ctrl+[A-Z] ã«å¤‰æ›
  if (mod[KEY_LEFTALT] || mod[KEY_RIGHTALT]) &amp;&amp;
     Rkremap::CODE_KEY[code] =~ /\AKEY_[A-Z]\z/
    mod[KEY_LEFTALT] = mod[KEY_RIGHTALT] = false
    mod[KEY_LEFTCTRL] = true
    rk.key(code, mod)
    next
  end
end
</code></pre>

</section>
<section>

<p>Ctrl-K å•é¡Œ</p>

<p>æ—¥æœ¬èªå…¥åŠ›ä¸­ã‹ã©ã†ã‹ã¯ fcitx-remote ã‚³ãƒãƒ³ãƒ‰ã§åˆ¤å®š</p>
<pre><code class="language-bash">while :; do
  if [ $(fcitx-remote) -eq 2 ]; then
    touch /tmp/fcitx-enabled
  else
    rm -f /tmp/fcitx-enabled
  fi
  sleep 0.1
done
</code></pre>

</section>
<section>

<p>çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«ã®æœ‰ç„¡ã§åˆ†å²</p>
<pre style="font-size:60%"><code class="language-ruby">  if mod[KEY_LEFTCTRL] || mod[KEY_RIGHTCTRL]
    # Ctrl+K/I/O ã¯æ—¥æœ¬èªå¤‰æ›æ™‚ã¯ãã®ã¾ã¾
    if code == KEY_K &amp;&amp; File.exist?('/tmp/fcitx-enabled')
      rk.key(code, mod)
      next
    end
    # Ctrl+K ã¯è¡Œæœ«ã¾ã§å‰Šé™¤
    if code == KEY_K
      rk.key(KEY_END, mod_disable_all.merge({KEY_LEFTSHIFT =&gt; true}))
      rk.key(KEY_X, mod_disable_all.merge({KEY_LEFTCTRL =&gt; true}))
      next
    end
    ...
</code></pre>

</section>
<section>

<p>ã‚­ãƒ¼ãƒ­ã‚¬ãƒ¼çš„ãªã‚„ã¤</p>

<pre style="font-size:60%"><code class="language-ruby">require 'rkremap'
def code2key(code)
  Rkremap::CODE_KEY[code].to_s.sub(/\AKEY_/, '')
end
rk = Rkremap.new
rk.grab = false
rk.x11 = true
rk.start do |code, mod, app|
  key = (mod.select{|_, v| v}.keys + [code]).map{|c| code2key(c)}.join('-')
  key &lt;&lt; " at #{app.title} [#{app.class_name}]" if rk.x11
  puts key
end
</code></pre>

</section>
<section>

<h3>ã‚­ãƒ¼ãƒªãƒãƒƒãƒ‘ãƒ¼ã®æ§‹æˆè¦ç´ æŠ€è¡“</h3>

</section>
<section>

<h3>ã‚­ãƒ¼å…¥åŠ›æƒ…å ±</h3>

</section>
<section>

<p><code>/dev/input/event*</code> ã‹ã‚‰24ãƒã‚¤ãƒˆèª­ã‚€</p>

<pre><code class="language-c">struct input_event {
  struct timeval time;  // ã‚¤ãƒ™ãƒ³ãƒˆç™ºç”Ÿæ—¥æ™‚
  // struct timeval { long int tv_usec, long int tv_nsec };
  unsigned short type;  // ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒ—
  unsigned short code;  // ã‚­ãƒ¼ã‚³ãƒ¼ãƒ‰(ã‚­ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆ)
  unsigned int value;   // 0:release / 1:press / 2:repeat
};
</code></pre>
<p>Rubyã§ï¼ˆè¦rootï¼‰</p>
<pre><code class="language-ruby">ev = File.open('/dev/input/event3')
raw = ev.sysread(24)
sec, usec, type, code, value = raw.unpack('Q!Q!SSl')
</code></pre>

</section>
<section>

<p>ThinkPad ã®ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã§ <code>A</code> ã‚’æŠ¼ã—ã¦é›¢ã™ã¨:</p>
<pre><code class="language-ruby">type       code       value
EV_MSC(4)  4          30   # ã‚ˆãã‚ã‹ã‚‰ã‚“
EV_KEY(1)  KEY_A(30)  1    # 'A' æŠ¼ã™
EV_SYN(0)  0          0    # åŒºåˆ‡ã‚Š
EV_MSC(4)  4          30   # ã‚ˆãã‚ã‹ã‚‰ã‚“
EV_KEY(1)  KEY_A(30)  0    # 'A' é›¢ã™
EV_SYN(0)  0          0    # åŒºåˆ‡ã‚Š
</code></pre>

</section>
<section>

<p>Ctrl ã‚„ Alt ç­‰ã®ä¿®é£¾ã‚­ãƒ¼ã‚‚æ™®é€šã®ã‚­ãƒ¼ã¨åŒã˜</p>

<p><code>Ctrl+A</code> (<code>EV_KEY</code> ã ã‘æŠœç²‹)</p>
<pre><code class="language-ruby">EV_KEY(1)  KEY_LEFTCTRL(29)  1  # 'CTRL' æŠ¼ã™
EV_KEY(1)  KEY_A(30)         1  # 'A' æŠ¼ã™
EV_KEY(1)  KEY_A(30)         0  # 'A' é›¢ã™
EV_KEY(1)  KEY_LEFTCTRL(29)  0  # 'CTRL' é›¢ã™
</code></pre>

</section>
<section>

<p>ã‚­ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã¯èª­ã‚ã‚‹ã‘ã©ã‚¢ãƒ—ãƒªã«ã‚‚æ¸¡ã‚‹</p>

<p>GRAB ã™ã‚Œã°ã‚¢ãƒ—ãƒªã«æ¸¡ã•ãšæ¨ªå–ã‚Šã§ãã‚‹</p>

<pre><code class="language-ruby">ev.ioctl(1074021776, 1)  # EVIOCGRAB
</code></pre>

<p><strong>ã‚­ãƒ¼å…¥åŠ›ãŒåŠ¹ã‹ãªããªã‚‹ã®ã§æ³¨æ„ï¼</strong></p>

</section>
<section>

<h3>ãƒ‡ãƒã‚¤ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã®é¸æŠ</h3>

</section>
<section>

<p>evtest</p>

<pre style="font-size:50%"><code class="language-txt">% sudo evtest
No device specified, trying to scan all of /dev/input/event*
Available devices:
/dev/input/event0:  Lid Switch
/dev/input/event1:  Sleep Button
/dev/input/event2:  Power Button
/dev/input/event3:  AT Translated Set 2 keyboard
/dev/input/event4:  Video Bus
/dev/input/event5:  Synaptics TM3145-003
/dev/input/event6:  ThinkPad Extra Buttons
/dev/input/event7:  HDA Intel PCH Dock Mic
/dev/input/event8:  HDA Intel PCH Mic
/dev/input/event9:  HDA Intel PCH Dock Headphone
/dev/input/event10: HDA Intel PCH Headphone
/dev/input/event11: HDA Intel PCH HDMI/DP,pcm=3
/dev/input/event12: HDA Intel PCH HDMI/DP,pcm=7
/dev/input/event13: HDA Intel PCH HDMI/DP,pcm=8
/dev/input/event14: HDA Intel PCH HDMI/DP,pcm=9
/dev/input/event15: HDA Intel PCH HDMI/DP,pcm=10
/dev/input/event16: TPPS/2 IBM TrackPoint
/dev/input/event17: Integrated Camera: Integrated C
</code></pre>

</section>
<section>

<p>ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒ‡ãƒã‚¤ã‚¹ã‹ã©ã†ã‹</p>
<pre><code class="language-ruby">EV_KEY = 0x01  # /usr/include/linux/input-event-codes.h ã‚ˆã‚Š
buf = ''
ev.ioctl(2147566880, buf)  # EVIOCGBIT(0, 1)
buf[0].ord &amp; EV_KEY  #=&gt; 1 ãªã‚‰ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒ‡ãƒã‚¤ã‚¹
</code></pre>

<p>ã‚­ãƒ¼ <code>A</code>, <code>Z</code> ã«å¯¾å¿œã—ã¦ã„ã‚‹ã‹</p>
<pre><code class="language-ruby">KEY_A = 30
KEY_Z = 44
ev.ioctl(2153792801, buf)  # EVIOCGBIT(EV_KEY, (KEY_MAX-1)/8+1)
buf.unpack('C*')[KEY_A/8][KEY_A%8] != 0  #=&gt; 'A' ã«å¯¾å¿œ
buf.unpack('C*')[KEY_Z/8][KEY_Z%8] != 0  #=&gt; 'Z' ã«å¯¾å¿œ
</code></pre>

</section>
<section>

<h3>ä»®æƒ³ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒ‡ãƒã‚¤ã‚¹ã®ä½œæˆ</h3>

</section>
<section>

<p><code>/dev/uinput</code> ã§ä»®æƒ³å…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹ã‚’ä½œã‚Œã‚‹ï¼ˆè¦rootï¼‰</p>

<pre><code class="language-ruby">udev = File.open('/dev/uinput', 'w')
udev.ioctl(1074025828, EV_KEY)  # UI_SET_EVBIT   ã‚­ãƒ¼ãƒ‡ãƒã‚¤ã‚¹
udev.ioctl(1074025829, KEY_A)   # UI_SET_KEYBIT  KEY_A ã‚’å…¥åŠ›å¯èƒ½
udev.ioctl(1074025829, KEY_Z)   # UI_SET_KEYBIT  KEY_Z ã‚’å…¥åŠ›å¯èƒ½
setup = [0x03, 0x1234, 0x5678, 1, 'name', 0].pack('SSSSZ80L')
  # ãƒ‡ãƒã‚¤ã‚¹æƒ…å ±ã¯ã¦ãã¨ãƒ¼
udev.ioctl(1079792899, setup)   # UI_DEV_SETUP   ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
udev.ioctl(21761)               # UI_DEV_CREATE  ä½œæˆ
</code></pre>

</section>
<section>

<p>ä½œã‚‰ã‚ŒãŸãƒ‡ãƒã‚¤ã‚¹ã‚’ evtest ã§è¦‹ã¦ã¿ã‚‹</p>

<pre style="font-size:65%"><code class="language-txt">% sudo evtest /dev/input/event19
Input driver version is 1.0.1
Input device ID: bus 0x3 vendor 0x1234 product 0x5678 version 0x1
Input device name: "name"
Supported events:
  Event type 0 (EV_SYN)
  Event type 1 (EV_KEY)
    Event code 30 (KEY_A)
    Event code 44 (KEY_Z)
</code></pre>

<p><code>A</code> ã¨ <code>Z</code> ã—ã‹å…¥åŠ›ã§ããªã„ãƒ‡ãƒã‚¤ã‚¹</p>

</section>
<section>

<p>ã‚­ãƒ¼å…¥åŠ›ã‚¤ãƒ™ãƒ³ãƒˆã®ä½œæˆ</p>

<p><code>A</code> ã‚’æŠ¼ã—ã¦é›¢ã™</p>

<pre style="font-size:65%"><code class="language-ruby"># æ™‚åˆ»ã¯ä¸è¦
udev.syswrite(['', EV_KEY, KEY_A, 1].pack('a16SSl'))  # push A
udev.syswrite(['', EV_SYN, 0, 0].pack('a16SSl'))      # åŒºåˆ‡ã‚Š

udev.syswrite(['', EV_KEY, KEY_A, 0].pack('a16SSl'))  # release A
udev.syswrite(['', EV_SYN, 0, 0].pack('a16SSl'))      # åŒºåˆ‡ã‚Š
</code></pre>

</section>
<section>

<p>æ¯ç§’ A-Z ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«æ›¸ãè¾¼ã‚€è¿·æƒ‘ãªã‚„ã¤</p>

<pre><code class="language-ruby">keys = ('A'..'Z').map{eval "KEY_#{_1}"}
while true
  key = keys.sample
  udev.syswrite(['', EV_KEY, key, 1].pack('a16SSl'))
  udev.syswrite(['', EV_SYN, 0, 0].pack('a16SSl'))
  udev.syswrite(['', EV_KEY, key, 0].pack('a16SSl'))
  udev.syswrite(['', EV_SYN, 0, 0].pack('a16SSl'))
  sleep 1
end
</code></pre>

</section>
<section>

<p>ioctl ã¨ã‹ read / write ã˜ã‚ƒãªãã¦ libevdev (evdev gem) ã‚‚ã‚ã‚‹ã‚“ã§ãã‚Œã‚’ä½¿ã†ã®ã‚‚è‰¯ã•ãã†</p>

</section>
<section>

<h3>ã‚­ãƒ¼å¤‰æ›å‡¦ç†ã¾ã¨ã‚</h3>

<ul>
  <li>
<code>/dev/input/event*</code> ã‚’ GRAB ã—ã¦ã‚­ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã‚’èª­ã‚€</li>
  <li>ã‚¤ãƒ™ãƒ³ãƒˆã‚’åŠ å·¥</li>
  <li>
<code>/dev/uinput</code> ã§ä½œæˆã—ãŸãƒ‡ãƒã‚¤ã‚¹ã«æ›¸ãè¾¼ã‚€</li>
</ul>

</section>
<section>

<h3>X ã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ã‚¿ã‚¤ãƒˆãƒ«ã‚’å¾—ã‚‹</h3>

</section>
<section>

<p>ç‰¹å®šã®ã‚¢ãƒ—ãƒªã ã‘ã§æœ‰åŠ¹ã«ã—ãŸã„ã¨ã‹ç„¡åŠ¹ã«ã—ãŸã„ã¨ã‹</p>

</section>
<section>

<p>X11 ã§å…¥åŠ›ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ãŒã‚ãŸã£ã¦ã‚‹ã‚¢ãƒ—ãƒªåã®å–å¾—</p>

<p>C ã®å ´åˆï¼ˆã–ã£ãã‚Šã¨ï¼‰:</p>

<ol>
  <li>
<code>XGetInputFocus()</code> ã§ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ Window å–å¾—</li>
  <li>
<code>XGetClassHint()</code> ã§ Window ã®ã‚¯ãƒ©ã‚¹åã‚’å–å¾—</li>
  <li>ã‚¯ãƒ©ã‚¹åãŒå¾—ã‚‰ã‚ŒãŸã‚‰ <code>XGetWMName()</code> ã§ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¿ã‚¤ãƒˆãƒ«ã‚’å¾—ã‚‹</li>
  <li>ã‚¯ãƒ©ã‚¹åãŒ <code>NULL</code> ãªã‚‰ <code>XQueryTree()</code> ã§è¦ª Window ã‚’å¾—ã¦ 2 ã«æˆ»ã‚‹</li>
</ol>

</section>
<section>

<p>Ruby ã«ã¯è‰¯ã•ãã†ãª X11 ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒãªã•ãã†</p>

<p>X11 ã®å…¨æ©Ÿèƒ½ã‚’ç¶²ç¾…ã™ã‚‹ã®ã¯å¤§å¤‰ãã†ã ã—</p>

<pre><code class="language-sh">% ls /usr/share/man/man3 | grep -c '^X.*\.3\.gz$'
1231
</code></pre>

</section>
<section>

<p>C æ‹¡å¼µã‚’æ›¸ãã®ã‚‚ã‚¢ãƒ¬ãªã®ã§</p>

<p>Fiddle ã§ libX11 ã‹ã‚‰å¿…è¦ãªæ©Ÿèƒ½ã‚’ã¤ã¾ã¿é£Ÿã„</p>

</section>
<section>

<h3>Fiddle</h3>

<p>Ruby ã‹ã‚‰ C ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªé–¢æ•°ã‚’å‘¼ã³å‡ºã›ã‚‹</p>

<p>ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ä¸è¦</p>

<pre><code class="language-ruby">require 'fiddle/import'
module C
  extend Fiddle::Importer
  dlload 'libc.so.6'
  extern 'int atoi(const char *nptr)'
end
p C.atoi("123")  #=&gt; 123
</code></pre>

</section>
<section>

<p>æ§‹é€ ä½“ã‚„ãƒã‚¤ãƒ³ã‚¿ã‚‚æ‰±ãˆã‚‹</p>

<pre style="font-size:65%"><code class="language-ruby">require 'fiddle/import'
module C
  extend Fiddle::Importer
  dlload 'libc.so.6'
  typealias 'time_t', 'long int'
  typealias 'suseconds_t', 'long int'
  Timeval = struct(['time_t tv_sec', 'suseconds_t tv_usec'])
  extern 'int gettimeofday(struct timeval *tv, struct timezone *tz)'
end
timeval = C::Timeval.malloc(Fiddle::RUBY_FREE)  # GCæ™‚ã«è§£æ”¾ã•ã‚Œã‚‹
C.gettimeofday(timeval, nil)
p timeval.tv_sec   #=&gt; 1970-01-01 00:00:00 UTC ã‹ã‚‰ã®çµŒéç§’æ•°
p timeval.tv_usec  #=&gt; ãƒã‚¤ã‚¯ãƒ­ç§’
</code></pre>

</section>
<section>

<p>å¿…è¦ãªé–¢æ•°ã®ã¿ä½¿ãˆã‚‹ã‚ˆã†ã«ã—ã¦</p>
<pre style="font-size:50%"><code class="language-ruby">module X11
  extend Fiddle::Importer
  dlload 'libX11.so.6'
  typealias 'XID', 'unsigned long'
  typealias 'Window', 'XID'
  typealias 'Status', 'int'
  typealias 'Atom', 'unsigned long'
  Window = struct ['Window window']
  Pointer = struct ['void *ptr']
  XClassHint = struct ['char *name', 'char *class_name']
  XTextProperty = struct ['unsigned char *value', 'Atom encoding', 'int format',
                          'unsigned long nitems']
  extern 'Display* XOpenDisplay(char*)'
  extern 'int XGetInputFocus(Display*, Window*, int*)'
  extern 'int XGetClassHint(Display*, Window, XClassHint*)'
  extern 'Status XQueryTree(Display*, Window, Window*, Window*, Window**, unsigned int*)'
  extern 'Status XGetWMName(Display*, Window, XTextProperty*)'
  extern 'int Xutf8TextPropertyToTextList(Display*, XTextProperty*, char***, int*)'
  extern 'int XFree(void*)'
  extern 'void XFreeStringList(char**)'
end
</code></pre>

</section>
<section>

<p>ã–ã£ãã‚Šã“ã‚“ãªæ„Ÿã˜</p>

<p style="font-size:60%">(ãƒ›ãƒ³ãƒˆã¯X11ãŒç¢ºä¿ã—ãŸãƒ¡ãƒ¢ãƒªã®è§£æ”¾å‡¦ç†ã‚‚å¿…è¦)</p>

<pre style="font-size:50%"><code class="language-ruby">class_hint = X11::XClassHint.malloc(Fiddle::RUBY_FREE)
parent = X11::Window.malloc(Fiddle::RUBY_FREE)
children = X11::Pointer.malloc(Fiddle::RUBY_FREE)
_ = ' '*8
display = X11.XOpenDisplay(nil)
w = X11::Window.malloc(Fiddle::RUBY_FREE)
X11.XGetInputFocus(display, w, _)
win = w.window
while win &gt; 0
  class_hint.name = class_hint.class_name = nil
  X11.XGetClassHint(display, win, class_hint)
  break unless class_hint.name.null? &amp;&amp; class_hint.class_name.null?
  X11.XQueryTree(display, win, _, parent, children, _)
  win = parent.window
end
prop = X11::XTextProperty.malloc(Fiddle::RUBY_FREE)
text_list = X11::Pointer.malloc(Fiddle::RUBY_FREE)
X11.XGetWMName(display, win, prop)
X11.Xutf8TextPropertyToTextList(display, prop, text_list, _)
p [class_hint.class_name.to_s, text_list.ptr.ptr.to_s.force_encoding('utf-8')]
</code></pre>

</section>
<section>

<h3>ã¾ã¨ã‚</h3>

<ul>
  <li>
<code>/dev/input/event*</code> ã§å…¥åŠ›ã‚¤ãƒ™ãƒ³ãƒˆã‚’èª­ã‚ã‚‹</li>
  <li>
<code>/dev/input/event*</code> ã‚’ GRAB ã™ã‚‹ã¨å…¥åŠ›ãŒã‚¢ãƒ—ãƒªã«æ¸¡ã‚‰ãªããªã‚‹</li>
  <li>
<code>/dev/uinput</code> ã§ä»®æƒ³å…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹ã‚’ä½œã‚Œã‚‹</li>
  <li>å¤§ããªãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®é–¢æ•°ã‚’ã¤ã¾ã¿é£Ÿã„ã™ã‚‹ã«ã¯ Fiddle ãŒä¾¿åˆ©</li>
</ul>

</section>
